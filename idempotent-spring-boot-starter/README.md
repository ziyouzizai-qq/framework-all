# idempotent-spring-boot-starter
通用的幂等性解决方案

幂等性：在数学领域中，指的是该操作可以被重复执行，但结果仍然保持不变的性质。但在计算机领域中，添加数据的操作是要考虑幂等的。


##解决方案

###1.DLC机制：
    通过分布式锁控制添加逻辑保证只有一个线程可以成功落库，在执行落库逻辑前，需要业务方提供一个校验数据是否成功落库的方法，
    并且该机制提供两种校验方法，一种是lock-check，另一种是check-lock-check，当前方案默认是前者，前者会比后者少调用一次check,
    后者则比前者降低获取lock的频率.这套方案让整个保证幂等性的周期取决于业务方的校验方法，如果校验是否落库的逻辑完全是缓存，则保证幂等
    性的周期为缓存过期时间，如果想使得幂等性周期是持久的，对应的校验查询一定是通过持久层，因此推荐该方法，使用缓存+持久层的校验来保证永久的幂等性。

###2.Token机制：
    在调用接口前生成一个Token（例如UUID），并将其保存在Redis服务端。每次接口请求时，将Token作为参数传递给服务端并校验Token的有效性。如果Token已失效
    则说明重复提交，返回错误信息。如果Token仍然有效，则执行业务逻辑并删除Token。这种机制表明当token不在redis时，认为该请求已经执行过，存在幂等性问题
    但是有可能受到token定时过期和缓存过期策略影响，导致第一次请求也会认为是幂等请求。因此token机制，需要制定一些业务上下文，才能保证该机制的正确。

###3.State机制
    通过在调用业务逻辑前查看状态来确保不重复消费，把状态保存到redis中，因此该机制存在幂等性时效性问题，需要对每一个配置时间，但是时效过了，则不会再保证幂等性。
    当状态CONSUMING时有以下情况：1. 有另一个线程在消费. 2. 有另一个线程执行业务逻辑前状态变更为CONSUMING后，还未执行业务逻辑，服务挂了，当前状态则一直到缓存过期
    在这段期间后续合法的重试请求而得不到消费，因此要设置一个合理的参数consumingExpirationDate。这个时间取决于各自的业务，首先不能太长，否则出现情况2，等待过期时间太长
    但是能多短取决各自逻辑处理，但是这个时长一定要大于处理业务逻辑的时间，否则有可能会出现幂等性问题。


##控制幂等的条件

###1. 上游生成出的的唯一键，或者业务相关的唯一，例如userid + xxName
    可以通过生成uuid，流水号，雪花算法来作为相同请求的依据，此类用途最广，且最保险，上述三种机制都可以
###2. 由自身的全参文本组成的唯一键，且全参文本中并不存在唯一标识，如果存在，则此类视为场景1

    如果业务场景允许相同的请求做插入操作，还没有唯一标记，这种场景就无法控制幂等，准确的说无法知道哪些请求是幂等，哪些不是幂等。但是如果要控制幂等
    就必须引入唯一键。这种场景存在，比如说点份外卖，昨天在A店点了一份B套餐，今天又把昨天的订单再来了一遍，其文本是一样的，这种情况允许同样的文本插入库中，
    但是为了解决幂等性，因此订单都会提前生成好一份流水号（或者根据订单生成时间），所以这种业务场景就统一归类于场景1。

    适用场景：业务本身不存在生产两次相同的文本，但是有可能生产的时候连发两次，因此消费端就可以用场景2来解决，如果有必要，可以生产端和消费端都做幂等。

    
